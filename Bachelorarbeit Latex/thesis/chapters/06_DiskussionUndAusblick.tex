%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Zusammenfassung und Fazit}
\label{chap:intro}
Nachdem in den vorherigen Kapiteln theoretische Grundlagen, wissenschaftliche Arbeiten und ein selbst entwickelter Prototyp mit Messungen dazu eingesetzt wurden  um Unterschiede der API-Architekturen zu ermitteln, werden in diesem Kapitel die Ergebnisse für die Beantwortung der Forschungsfragen zusammengeführt.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterstart
\section{Beantwortung der Forschungsfragen}
\subsection*{Forschungsfrage 1}
\textit{Wie wirkt sich die Verwendung von gRPC bzw. gRPC-Web im Vergleich zu REST und GraphQL auf die Latenz, Effizienz und Ressourcennutzung in der Frontend-Backend-Kommunikation aus?}

\textbf{Latenz:} 
Bezogen auf die Latenz werden der entwickelte Prototyp der die End-zu-End Latenz gemessen hat, und einige verwandte wissenschaftliche Arbeiten herangezogen.
Die Messergebnisse des Prototyp zeigen, dass die Eignung der Architektur stark von de Datengröße abhängt. 
In Browserumgebungen, in denen nur gRPC-Web verwendet wird, erwiesen sich GraphQL und gRPC Web bei kleinen Datengrößen (einige Bytes bis kB) am performantesten, wobei der Abstand zu REST mit 1-2 ms nicht sehr hoch ist. 
Werden jedoch größere Textdaten geschickt (100kB), ist gRPC-Web mit einigen ms deutlich langsamer als GraphQL und REST. Bei der Übertragung von großen Binärdaten ist REST eindeutig die beste Wahl. Grund dafür ist, dass einerseits GraphQL wegen Base64-Overhead mehr Daten senden muss. Auch die Chunk-Streaming Methode welche bei gRPC-Web für das senden von großen Daten implementiert wurde, konnte nicht effizient, und teilweise gar nicht, von den Browser Engines verarbeitet werden konnte. Hierbei ist zu erwähnen, dass selbst falls es geeignetere Implementationen geben sollte, die Lösungswege wie solche große Datenmengen im Browser übertragen werden sollen kaum dokumentiert sind. REST ist bezogen auf Erlernbarkeit und Dokumentation klar im Vorteil.
Im Microservice-Szenario ohne Browser-Overhead erreichte gRPC die geringsten Latenzen, während REST bei sehr großen Dateien (z.B. Video mit 100 MB) weiterhin am effizientesten war. gRPC-Web blieb konstant hinter REST und gRPC zurück.
Die Dominanz von gRPC gegenüber REST und GraphQL in Microservice-Architektur-Umgebungen konnte auch von zahlreichen verwandten Arbeiten in der theoretischen Analyse bestätigt werden, wobei in diesen Arbeiten auch gezeigt wurde, dass auch bei sehr kleinen Datenmengen im Byte Bereich, REST aufgrund von weniger Overhead schneller ist.

\textbf{Effizienz:} 
Hinsichtlich der Effizienz ergibt sich aus der theoretischen Analyse, dass gRPC und gRPC-Web aufgrund der Verwendung von Protobuf (und in Microservice Umgebungen auch aufgrund von HTTP/2-Mulitplexing) den geringsten Overhead aufweisen und vor allem bei vielen kleinen Nachrichten Vorteile bieten. REST und GraphQL sind bei einfachen Abfragen ähnlich effizient, wobei GraphQL durch gebündelte Abfragen das Problem des Over- bzw. Under-Fetchings vermeiden kann, was wiederum einen hohen Effizienzgewinn bringen könnte. Wie bereits erwähnt, ist GraphQL aufgrund der notwendigen Base64-Kodierung, welche  mit rund einem Drittel zusätzlichem Overhead einhergeht deutlich weniger geeignet für große Binärdaten. Einige Browserengines, konnten diese GraphQL-Responses auch nicht verarbeiten. Bezogen auf Effizienz im Browserumfeld ist REST der klare Gewinner.

\textbf{Ressourcennutzung:} 
Bezüglich der Ressourcennutzung ergibt sich aus der theoretischen Analyse, dass gRPC und gRPC-Web durch das Protobuf-Parsing weniger CPU-Leistung als REST und GraphQL verbrauchen, da JSON-Parsin aufwändiger ist. GraphQL ist an sich am ressourvenintensivsten, kann jedoch durch die Flexibilität und das verhindern von Over- bzw. Under-Fetching wiederum Ressourcen einsparen.

Insgesamt zeigt sich, dass die Wahl der API-Architektur stark von der Datenmenge und der Umgebung abhängt. Während gRPC der klare Gewinner bezogen auf Latenz (abgesehen von sehr kleinen und sehr großen Daten), Ressourcennutzung und Effizienz ist, zeigt gRPC-Web in der Web-Umgebung bezogen auf diese Parameter kaum Vorteile. Ein Grund für die hohen Performanceeinbußen von gRPC zu gRPC-Web könnte, abgesehen von dem Fehlen von gRPC-Features, damit erklärt werden, dass bei der Verwendung von gRPC-Web, Übersetzungsschritte notwendig sind, die das gRPC in das gRPC-Web Protoll umwandeln, nowendig sind.

\subsection*{Forschungsfrage 2}
\textit{Unter welchen Bedingungen ist der Einsatz von gRPC für die Frontend-Backend-Kommunikation sinnvoller als REST oder GraphQL?}

Die Messergebnisse sowie die theoretische Analyse zeigen, dass sich der Einsatz von gRPC performancetechnisch vorallem in Service-zu-Service Architekturen lohnt. Die effiziente binäre Serialisierung mittels Protobuf und die Nutzung von HTTP/2  führen im Vergleich zu REST zu einer geringere Latenz, höhere Effizienz und niedrigeren Ressourcenverbrauch. Dies kann insbesondere dann von großem Vorteil sein, wenn die Performance eine zentrale Rolle spielt.

Handelt es sich bei dem Frontendclient jedoch um einen Web-Browser, kann gRPC nicht mehr verwendet werden, und es muss das eigens dafür entwickelte gRPC-Web Protokoll verwendet werden, bei welchen zentrale Vorteile von gRPC verloren gehen und zusätzliche Übersetzungsschritte erforderlich sind. Wie die Messergebnisse zeigen, lohnt sich der Einsatz von gRPC-Web aus Performancesicht nicht. Es lässt sich keine Verbesserung der Latenz feststellen, und im Vergleich zum etablierten REST, kommt es zu Problemen bei der Übertragung von größeren Mediendaten. Abgesehen davon ist die Erlernbarkeit im Vergleich zu etablierten Technologien wie REST deutlich komplexer und es stehen weniger Dokumentation, Tools und Community-Ressourcen zur Verfügung. GraphQL eignet sich im Frontend-Client besonders gut, um Over- und Underfetching zu vermeiden und es bestehen im Vergleich zu gRPC-Web deutlich mehr Ressourcen zur Verfügung, ist einfacher zu erlernen und performancetechnisch nicht schlechter. 
Aus diesen genannten Gründen wird geschlussfolgert, dass der Einsatz von gRPC-Web nur dann sinnvoll, wenn die bestehende Systemarchitektur bereits stark auf gRPC im Backend aufbaut und die Webintegration lediglich eine Erweiterung darstellt. Für große Binärdaten oder einfache Abfragen sind REST und GraphQL im Browser jedoch die bessere Wahl.


Zusammenfassend ist gRPC-Web im Browserumfeld aus performancetechnischen Gründen nicht sinnvoller als REST oder GraphQL. Hier überwiegen die Nachteile, sodass REST und GraphQL die praktikableren Lösungen darstellen. Im Backend-Kontext hingegen ist gRPC sinnvoller, da es dort eine besonders effiziente, performante und ressourcenschonende Kommunikation ermöglicht.


\section{Ausblick}
Wie in der Arbeit feststellt, stellt gRPC-Web momentan keine eindeutige Alternative zu den etablierten Standards wie REST oder GraphQL für die Frontend zu Backendkommunikation in Webbrowsern dar. Mit der Weiterentwicklung moderner Webbrowser und einer somit umfassenden Unterstützung von HTTP/2 könnte sich die Leistungsfähigkeit von gRPC-Web jedoch verbessern. Eine steigende Popularität, könnte demnach dann ebenfalls zu mehr Dokumentation, Tools und Community-Ressourcen führen. Dadurch ist es möglich, dass gRPC in Zukunft performancetechnisch dennoch konkurrenzfähiger zu REST und GraphQL im Browserkontext wird und damit auch für die Frontend-Backend-Kommunikation eine relevantere Rolle einnimmt.
\chapterend
