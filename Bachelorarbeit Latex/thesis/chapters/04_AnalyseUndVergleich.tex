%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Theoretische Analyse und Vergleich der API-Technologien:}
\label{chap:intro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterstart
Aufbauend auf den theoretischen Grundlagen und dem Stand der Technik, sollen anschließend die ausgewählten API-Technologien: REST, GraphQL, gRPC und gRPC-Web direkt miteinander verglichen werden. Neben den technischen Eigenschaften sollen auch Aspekte wie Erlernbarkeit, Effizienz und Ressourcenverbrauch betrachtet werden. Ziel des Kapitels ist es, die jeweiligen Stärken und Schwächen der Technologien herauszuarbeiten und aufzuzeigen.

\section{Vor- und Nachteile der API-Technologien}
Im folgenden Abschnitt werden jeweils die Vor- und Nachteile der API-Architekturen herausgearbeitet, um diese im direkten Vergleich gegenüberstellen zu können. 
\subsection{REST}

\paragraph{Vorteile:}
\begin{itemize}
	\item REST ist der etablierteste API-Standard für Web-APIs.
	\item Ein Großteil der Entwickler ist bereits mit dem Standard vertraut.
	\item Durch die weite Verbreitung gibt es eine Vielzahl an Tools für die Entwicklung und das Testing (z.B. Postman, Swagger) \parencite{postman2022, postman2023}.
	\item Wird in den meisten Web-Clients nativ unterstützt und liefert typischerweise JSON, welches für Menschen leicht lesbar ist.
	\item Es ist im Vergleich einfach und intuitiv aufgebaut.
	\item HTTP-Funktionen wie Caching und Authentifizierung können direkt genutzt werden.
	\item Jeder Request ist zustandslos, das heißt, alle Kontextinformationen müssen immer mitgeliefert werden. Vorteile davon sind Skalierbarkeit, Ausfallsicherheit und einfacheres Design \parencite{fielding2000rest}. 
\end{itemize}

\paragraph{Nachteile:}
\begin{itemize}
	\item Der größte Nachteil von REST ist das Over-Fetching bzw. Under-Fetching. Es gibt klar definierte Endpunkte die einen gewissen Datenansatz zurückliefern. Hierbei kann es zu dem Problem kommen, dass man mehr Daten übertragen muss, als man benötigt, was zu zusätzlichen Netzwerklast und höheren Latenzen führt \parencite{amazon2025graphql}.
	\item Die Zustandslosigkeit hat auch einen Nachteil, alle Kontextinformationen müssen immer mitgeliefert werden, was bei einer Vielzahl von Requests ineffizient ist \parencite{fielding2000rest}.
	\item Versionierung: Änderungen der API erfordern oft neue Endpunktversionen, was die Wartung erschweren kann.
	\item Auch wenn meist JSON für die Übertragung genutzt wird, gibt es an sich keine strikte Typsicherheit \parencite{redhat-apiguide}. 
\end{itemize}

\subsection{GraphQL}

\paragraph{Vorteile:}
\begin{itemize}
	\item GraphQL bietet eine präzise Datenabfrage, der Client bekommt genau die Menge an Daten, die benötigt wird, Over-Fetching bzw. Under-Fetching wird verhindert.
	\item Mehrere Ressourcen können in einer Anfrage kombiniert werden, im Gegensatz zu REST, wo mehrere Endpunkte separat aufgerufen werden müssen. Diese Eigenschaft verringert die Netzwerkrundläufe, was vor allem bei langsamen oder mobilen Verbindungen effizient ist.
	\item . GraphQl ist stark typisiert, alle verfügbaren Datenytpen und Felder sind definiert und können vom Client abgefragt werden, was die Entwicklung erleichtert. 
	\item Neue Felder können einfach hinzugefügt werden ohne bestehende Queries verändern zu müssen.
\end{itemize}

\paragraph{Nachteile:}
\begin{itemize}
	\item Die Flexibilität die durch GraphQl für das Frontend schafft, verlagert die Komplexität auf den Server. 
	\item Die Implementierung kann ohne Batch-Loading oder Caching-Strategien zu Performance Einbußen führen, da meistens alle Abfragen über nur einen einzigen /graphql-Endpoint per POST laufen, und somit das übliche http-Caching- nicht automatisch funktioniert. 
	\item Das fehlen des eingebauten HTTP-Caching führt dazu, dass Entwickler eigeine Cashing-Lösungen implementieren müssen. 
	\item Durch die frei gestaltbaren Queries ist es außerdem schwierig, paschale Limits oder Vorhersagen über Lasten zu definieren \parencite{graphql-org,amazon2025graphql,redhat-apiguide}.
	\item Im Gegensatz zu REST ist GraphQl nicht weniger verbreitet und es gibt eine begrenztere Anzahl an Debugging Möglichkeiten \parencite{postman2022, postman2023}.
\end{itemize}

\subsection{gRPC}

\paragraph{Vorteile:}
\begin{itemize}
	\item gRPC ist für Performance ausgelegt.  
	\item Durch das Verwenden von Protocol Buffers, sind die gesendeten Nachrichten binär kodiert, äußerst kompakt und dadurch schneller übertragen als z.B. JSON. In der Web-Variabte gRPC-Web können diese Vorteile zum Teil auch im Browser genutzt werden. 
	\item In Kombination mit http/2.0 als Transport ermöglicht gRPC eine sehr niedrige Latenz und effiziente Ausnutzung der Verbindung (Multiplexing). 
	\item gRPC ist streng typisiert, und die zu sendenden Datenstrukturen als auch zur Verfügung stehenden Dienste sind in einer .proto Definition klar definiert. 
	\item Der klare Vertrag zwischen Client und Server erhöht die Typsicherheit, reduziert messstände und Fehler zur Laufzeit.
	\item gRPC unterstützt bidirektionales Streaming. 
	\item gRPC generiert automatisch Client-Code für viele Programmiersprachen \parencite{gRPCAbout}.
\end{itemize}

\paragraph{Nachteile:}
\begin{itemize}
	\item Da gRPC auf http/2 basiert und davon spezielle Features nutzt, die von vielen Webbrowsern nicht unterstützt werden, ist es ohne Weiteres nicht in Browser Umgebungen nutzbar. Die Lösung hierfür ist die Übersetzung von gRPC zu gRPC-Web, welches im Browser benutzt werden kann.
	\item Diese Die Übersetzung von gRPC zu gRPC-Web erhöht die Infrastruktur-Komplexität, kann zu Fehlerquellen führen, und mindert die Performance \parencite{grpc-web-docs}.
	\item gRPC wird nicht so häufig für die Kommunikation zwischen Web und Backend benutzt, dadurch gibt es weniger Debugging-Tools.
	\item Die Nutzung von gRPC ist nicht so intuitiv und einfach wie REST und erfordert eine Einarbeitung in neue Tools und Konzepte \parencite{redhat-apiguide}.
\end{itemize}

\section{Effizienzvergleich: Latenz, Datenvolumen und Ressourcenverbrauch}
Mehrere Studien zeigen, dass gRPC in Bezug auf Latenz, Datenvolumen und CPU-Verbrauch am performantesten ist. Die Ergebnisse werden nicht im Detail wiederholt, sondern in Bezug auf die drei API-Technologien eingeordnet.

\paragraph{Latenz und Antwortzeit:} gRPC erreicht durch HTTP/2 und Protobuf geringere Latenzen als REST und GraphQL. REST hat durch das Verwenden von JSON einen Overhead, kann aber bei wiederholten Requests vom Cache profitieren. GraphQL weist die höchsten Latenzen auf, kann aber durch individuelle Datenabfrage die Zahl der benötigten Requests minimieren und dadurch in Summe effizienter sein.


\paragraph{Datenvolumen:}  
gRPC überträgt die Daten durch Protobuf sehr kompakt. REST und GraphQL haben durch die Verwendung vom textbasierten JSON einen Overhead. GraphQL eignet sich am wenigsten für die Übertragung von Blobs, da diese in Base64 kodiert werden müssen, das den Overhead um ein Drittel erhöht.


\paragraph{Ressourcenverbrauch:}  
gRPC ist hinsichtlich der CPU-Auslastung am effizientesten, da Protobuf schneller verarbeitet wird als JSON. REST und GraphQL benötigen durch die aufwendigere Serialisierung und Deserialisierung mehr Rechenressourcen.

\section{Erlernbarkeit}

\subsection{REST}
Abgesehen von der weiten Verbreitung von REST, gilt diese Technologie auch als einfach erlernbar und schnell einsetzbar. Durch die Nutzung von Standard-http und einfachen CRUD-Methoden (GET, POST, etc. ) wird eine flache Lernkurve aufgewiesen. Es gibt zahlreiche Tools und Beispiele, was den Einstieg zusätzlich erleichtert. \parencite{redhat-apiguide,postman2023}.

\subsection{GraphQL}
GraphQl bringt aufgrund neuer Konzepte wie, Schemas, Queries, der eigenen Abfragesprache und der Resolver-Logik eine steilere Lernkurve als Rest auf \parencite{redhat-apiguide}.
Ein kontrolliertes Experiment zeigt jedoch auf, dass die Implementierung konkreter Abfragen mit GraphQL weniger Aufwand erfordern kann als REST \parencite{brito2020graphqlrest}. Generell ist GraphQl auch weniger verbreitet als REST wodurch Anfänger auf weniger Ressourcen zurückgreifen können
 \parencite{postman2023}.

\subsection{gRPC}

Auch gRPC hat im Vergleich zu REST einen erhöhten Einarbeitungsaufwand, da für die Verwendung die Konzepte von Protocol Buffers, Streaming-Kommunikation und dem Kompilieren von .proto-Dateien vertraut sein müssen. Außerdem braucht man eine spezfisiche Toolchain wie protoc und passende Codegeneratoren für die jeweilige Sprache. Entwicklerumfragen  zeigen auf, dass gRPC im Vergleich zu REST deutlich seltener eingesetzt wird und aufzeigt, dass Tools, Beispiele und Comunity-Ressourcen weniger verbeitet sind als bei REST \parencite{redhat-apiguide,gRPCAbout}.

Auch Entwicklerumfragen zeigen auf, dass REST die am einfachste zu erlerndende Technologie ist.


\chapterend